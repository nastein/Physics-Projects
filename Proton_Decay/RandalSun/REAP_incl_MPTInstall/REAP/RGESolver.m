(* The package `REAP' is written for Mathematica 7 and is distributed under the
terms of GNU Public License http://www.gnu.org/copyleft/gpl.html *)




BeginPackage["REAP`RGESolver`",{"REAP`RGEUtilities`","REAP`RGESymbol`"}];

Print["Loading REAP 1.9.3
"];

ClearAll[RGESetInitial];

RGESetInitial::usage="RGESetInitial[scale, initial conditions] sets the initial values at the energy <scale>. They are entered as replacement rules and can also contain options (e.g. to select the neutrino mass hierarchy). See the manual for the names of the variables and options in the different models.  The option RGESuggestion chooses between several sets of default values. If it is not given, the first set of default values is taken.  In general, these are the default values at the GUT scale.";


ClearAll[RGEGetRange];

RGEGetRange::usage="RGEGetRange[] returns the lower and the upper bound of the solved region.";


ClearAll[RGEGetInitial];

RGEGetInitial::usage="RGEGetInitial[] returns the scale at which the initial values are given and the initial values as a list of replacement rules. The different names of the replacement rules can be looked up in the manual in the section about the specific model.";


ClearAll[RGEGetParameters];

RGEGetParameters::usage="RGEGetParameters[model] returns the quantities that run in the <model>.";


ClearAll[RGEAddEFT];

RGEAddEFT::usage="RGEAddEFT[model, options] (alias for RGEAdd) specifies that <model> (must be a string, e.g. \"SM\") should be used as an effective theory (EFT) up to a cutoff energy given in the options.  If no cutoff is given, \[Infinity] is used.  The options can also be used to specify various parameters such as tan\[Beta].  See the REAP documentation for a complete list of the models and options available.";


ClearAll[RGEAdd];

RGEAdd::usage="RGEAdd[model, options] specifies that <model> (must be a string, e.g. \"SM\") should be used as an effective theory (EFT) up to a cutoff energy given in the options.  If no cutoff is given, \[Infinity] is used.  The options can also be used to specify various parameters such as tan\[Beta].  See the REAP documentation for a complete list of the models and options available.";


ClearAll[RGESolve];

RGESolve::usage="RGESolve[low, high, options] solves the RGEs between the 2 energies <low> and <high>. RGESolve accepts the same options as NDSolve. In addition, the option RGERemoveAutoGeneratedEntries determines whether automatically generated EFTs (such as the MSSM with 2 singlet neutrinos, if one started with 3 singlets) are removed before solving the RGEs. The default value is True. If it is set to False, no EFT will be removed.";
Options[RGESolve]=Options[NDSolve]~Join~{RGERemoveAutoGeneratedEntries->True};
SetOptions[RGESolve,Method->StiffnessSwitching];


ClearAll[RGEReset];

RGEReset::usage="RGEReset[] removes all EFTs and resets all options which have been changed by RGEAdd or RGESetOptions to their default values. Options which have been changed by RGESetModelOptions are not reset.";


ClearAll[RGERegisterModel];

RGERegisterModel::usage="RGERegister[Name, Context, Solve, GetSolution, suggest initial, set options, get options] registers a new model named <Name>. See the manual for more information, especially the section about defining a new model.";


ClearAll[RGERmAutoGen];

RGERmAutoGen::usage="RGERmAutoGen[] removes all EFT's which have been automatically inserted.";


ClearAll[RGESetEFTOptions];

RGESetEFTOptions::usage="RGESetEFTOptions[model, options] (alias for RGESetOptions) changes the options of the EFTs defined by RGEAdd with name matching <model>. Metacharacters like * and @ are allowed in the string <model>.";


ClearAll[RGESetModelOptions];

RGESetModelOptions::usage="RGESetModelOptions[model name, options] sets the options of the model <model name> globally. See the section about the specific model for a list of the options.";


ClearAll[RGESetOptions];

RGESetOptions::usage="RGESetOptions[model, options] changes the options of the EFTs defined by RGEAdd with name matching <model>. Metacharacters like * and @ are allowed in the string <model>.";


ClearAll[RGEChangeOptions];

RGEChangeOptions::usage="RGEChangeOptions[scale, options] sets the options of the model at the scale <scale>. See the manual for a list of the possible options in the section of the specific model.";


ClearAll[RGEGetEFTOptions];

RGEGetEFTOptions::usage="RGEGetEFTOptions[model] (alias for RGEGetOptions) returns the options set by RGEAdd or RGESetOptions for the EFT's whose names match <model> (must be a string and may contain wildcards).";


ClearAll[RGEGetModelOptions];

RGEGetModelOptions::usage="RGEGetModelOptions[model name] returns the options of the model <model name>. See the manual for a detailed list of possible options in the section about the specific model";


ClearAll[RGEGetOptions];

RGEGetOptions::usage="RGEGetOptions[model] returns the options set by RGEAdd or RGESetOptions for the EFT's whose names match <model> (must be a string and may contain wildcards).";


ClearAll[RGEGetSolution];

RGEGetSolution::usage="RGEGetSolution[scale, parameter, direction] returns the
solution of the RGEs at the energy <scale>. <parameter> (optional) specifies the
quantity of interest, e.g. RGEM\[Nu] (cf. the REAP documentation for the lists
of possible parameters for each model). If no <parameter> is given, the values
of all running quantities are returned. <direction> (optional) specifies which
EFT is used at thresholds. It will not have any effect, if <scale> is no threshold. The default value is 0, which indicates that the EFT
which is valid immediately below <scale> is used. If <direction> is positive,
the EFT which is valid above the threshold will be used.";


ClearAll[RGEGetTransitions];

RGEGetTransitions::usage="RGEGetTransitions[] returns the transitions (thresholds) between the various EFTs in a list containing the energy scale, the model name and its options.";


ClearAll[RGEGetCutoff];

RGEGetCutoff::usage="RGEGetCutoff[Scale] returns the next transition above <Scale>.";


ClearAll[RGEGetModel];

RGEGetModel::usage="RGEGetModel[Scale] returns the name of the model and its options which is defined at <Scale>. See the section about the specific model in the manual.";


ClearAll[RGEGetSolveModel];

RGEGetSolveModel::usage="RGEGetSolveModel[Modelname] returns the function to solve the model <Modelname>.";


ClearAll[RGEDelModel];

RGEDelModel::usage="RGEDelModel[Scale] removes the model at scale <Scale>.";


ClearAll[RGELoadAll];

RGELoadAll::usage="RGELoadAll[filename] loads the saved state which is given in <filename>.";


ClearAll[RGESaveAll];

RGESaveAll::usage="RGESaveAll[filename] saves the state to <filename>.";


ClearAll[RGELoadResults];

RGELoadResults::usage="RGELoadResults[model] loads the saved model which is given in <model>.";


ClearAll[RGESaveResults];

RGESaveResults::usage="RGESaveResults[] returns a variable containing the current model.";


ClearAll[RGESaveInitialData];

RGESaveInitialData::usage="RGESaveInitialData[] returns the initial values,
the boundary scale and the range used to solve the RGE.";



 Begin["`Private`"];

 Map[Needs,{"REAP`RGEUtilities`","REAP`RGESymbol`"}];
ClearAll[gRGEModel,gRGEModelGetParameters,gRGEModelSolve,gRGEModelSetOptions,gRGEModelGetOptions,gRGEModelGetInitial,gRGETransFunc,gRGETransModel];
gRGEModel={}; (* variables containing the different models *)
gRGEModelContext={}; (* variable containing the name of the context of the model *)
gRGEModelGetParameters={}; (* contains the Parameters of the gRGEModels *)
gRGEModelSolve={}; (* solve model *)
gRGEModelSetOptions={}; (* contains the functions to set the options of the model *)
gRGEModelGetOptions={}; (* contains the functions to get the options of the model *)
gRGEModelGetInitial={}; (* contains suggestions for initial parameters *)
gRGEModelOptions={}; (* contains the options of the model (only used by RGELoadAll and RGESaveAll)*)

gRGETransFunc={};
RGEIndexTo=1;RGEIndexFunc=2; (* constants which are indices for gRGETransFunc *)
gRGEModelGetSolution={}; (* contains functions returning the solution*)
RGEIndexSolution=1; (* constants which are indices for ModelGetSolution (RGEIndexFunc is also used) *)

gRGETransModel={};


(*variables*)
ClearAll[RGEModel, RGEIndexModel,RGEIndexOptions, RGEIndexCutoff,RGEIndexSolution];
RGEModel={}; (*List of the different ranges  <model>,<options>,<cutoff>,<solution> *)
RGEIndexModel=1; RGEIndexOptions=2;RGEIndexCutoff=3;RGEIndexSolution=4; (* constants *)

ClearAll[gRGEBoundaryScale, gRGEInitial];
gRGEBoundaryScale; (* scale where the initial values are set.*)
gRGEInitial={}; (* list of initial values *)

ClearAll[gRGESolutionValid, gRGEDown, gRGEUp];
gRGEDown; (*solution exists between gRGEDown and gRGEUp *)
gRGEUp;
gRGESolutionValid=False; (* RGESolution is the Solution obtained from gRGEInitial *)

(* internal functions *)
ClearAll[RGENIM];
RGENIM[pParameters_,pToOpts_,pFromOpts_]:=Block[{},
(* placeholder function in the transition table for functions which are not implemented yet *)
(* Exception: This function always throws the exception ---> RGENotImplementedYet
*)
	  Print["not implemented yet"];Throw[0,RGENotImplementedYet]
];


ClearAll[GetRGEModelRange];
GetRGEModelRange[pLogScale_,pDirection_:0]:=Block[{li,lDirection},
(* returns the Index to the Range containing scale *)
(* Exception: scale too big ---> RGEScaleTooBig
*)
        If[pDirection>0,lDirection=1,lDirection=0];

	li=1;
	While[li<=Length[RGEModel],
		If[RGEModel[[ li, RGEIndexCutoff ]] < pLogScale,li++,Break[] ]
	];
        If[li>Length[RGEModel],Throw[Length[RGEModel],RGEScaleTooBig]];
	If[pLogScale==RGEModel[[ li,RGEIndexCutoff ]],li+=lDirection];
        If[li>Length[RGEModel],Throw[Length[RGEModel],RGEScaleTooBig]];
	Return[li];
];

ClearAll[UpdateTransition];
UpdateTransition[]:=Block[{liMax,ljMax,lIndexModel,li,lj},
(* creates the transition table gRGETransModel. This function has to be invoked after all models have been registered and before any calculation is done *)
	liMax=Length[gRGEModel];
	gRGETransModel=Table[RGENIM,{li,liMax},{lj,liMax}];
	Do[	ljMax=Length[ gRGETransFunc[[li]] ];
		Do[
                        If[MemberQ[gRGEModel,gRGETransFunc[[li,lj,RGEIndexTo]]],
                            lIndexModel=Flatten[Position[ gRGEModel,gRGETransFunc[[li,lj,RGEIndexTo]] ]][[ 1 ]];
			    gRGETransModel[[ lIndexModel, li]]=gRGETransFunc[[ li,lj,RGEIndexFunc ]];
                        ],{lj,1,ljMax}],{li,1,liMax}];
];



RGESetInitial[pBoundary_?NumericQ,pInitial___:{}]:= Block[{lIndexModel,lIndexRGEModel},
(* sets initial values *)
(* exceptions: pBoundary<0 --> RGELessThanZero
*)
   If[pBoundary<0,Throw[pBoundary,RGELessThanZero]];
   If[Length[RGEModel]==0,
       Print["There is no model defined yet. Use RGEAddEFT to define the model you want to use before you use RGESetInitial to set the initial conditions."];
       Return[];
   ];
   Catch[
        lIndexRGEModel=GetRGEModelRange[Log[pBoundary]],
	RGEScaleTooBig,
	(Print["There is no model defined at the given scale ",pBoundary,"."];Throw[pBoundary,RGEScaleTooBig];)&
	];
   lIndexModel=RGEModel[[lIndexRGEModel,RGEIndexModel]];
   gRGEInitial=gRGEModelGetInitial[[ lIndexModel ]][
   Flatten[{Sequence[pInitial]}~Join~RGEModel[[lIndexRGEModel,RGEIndexOptions]] ]];
   gRGEBoundaryScale=Log[pBoundary];
   gRGESolutionValid=False;
];


RGEGetRange[]:=Block[{},
(* returns the range where the RGE is solved *)
	Return[{gRGEDown,gRGEUp}];
	];


RGEGetInitial[]:=Block[{},
(* returns the initial values *)
	Return[{Exp[gRGEBoundaryScale],gRGEInitial}]
	];


RGEGetParameters[pModel_]:=Block[{lIndexModel},
   lIndexModel=Flatten[Position[gRGEModel,pModel]][[1]];
   Return[gRGEModelGetParameters[[lIndexModel]][]];
];


RGEAddEFT[pModel_,pOpts___:{}] := Block[{lIndexRGEModel,lIndexModel,lLogCutoff,lCutoff},
(* add new range to RGE model *)
(* exceptions: pCutoff less than 0 --> RGELessThanZero
*)
   lCutoff=(RGECutoff/.{Sequence[pOpts]})/.{RGECutoff->\[Infinity]};
   If[lCutoff<0,Throw[lCutoff,RGELessThanZero]];
   lLogCutoff=Log[lCutoff];
   lIndexRGEModel=1;
   While[lIndexRGEModel<=Length[RGEModel],
	If[RGEModel[[ lIndexRGEModel,RGEIndexCutoff ]] <
	lLogCutoff,lIndexRGEModel++,
	  If[RGEModel[[ lIndexRGEModel,RGEIndexCutoff ]] == lLogCutoff,
	    Print["There is already a model defined with the same cutoff. Thus
	    the model ", pModel," was not added."];
	    Return[],
	    Break[] ];
	];
   ];
   lIndexModel=Flatten[ Position[gRGEModel,pModel] ][[ 1 ]];
   lOpts;
   Options[lOpts]=gRGEModelGetOptions[[lIndexModel]][];
   RGEModel=Insert[RGEModel,{lIndexModel,{RGEFilterOptions[lOpts,pOpts]},lLogCutoff,{}},lIndexRGEModel];
   gRGESolutionValid=False;
]; 


RGEAdd[pModel_,pOpts___:{}]:=RGEAddEFT[pModel,pOpts];


RGESolve[pDown_?NumericQ,pUp_?NumericQ,pOpts___]:=Block[{lRGEDown,lRGEUp,lIndexRGEModel, lIndexModel, lOldIndexModel, lGoUp, lGoDown, lInitial,lUp,lUpModel,lUpOptions,lDown,lDownModel,lDownOptions,lNewScale,lAddedModels,lSolution},
(* solves the RGE *)
(* exceptions: parameters less than 0 --> RGELessThanZero
	       parameters too big --> RGEScaleTooBig
*)
	lNDSolveOpts;
	Options[lNDSolveOpts]=Options[RGESolve];
	SetOptions[lNDSolveOpts,RGEFilterOptions[NDSolve,pOpts]];

      lOpts;
      Options[lOpts]=Options[RGESolve];
      SetOptions[lOpts,RGEFilterOptions[RGESolve,pOpts]];

(* check pDown and pUp *)
   If[Length[gRGEInitial]==0,
       Print["There are no initial conditions set yet. Use RGESetInitial
   to set the initial conditions before you use RGESolve to solve the RGEs."];
       Return[];
   ];
   If[Length[RGEModel]==0,
       Print["There is no model defined yet. Use RGEAdd to define the model you want to use before you use RGESolve to solve the RGEs."];
       Return[];
   ];
   If[gRGEBoundaryScale>RGEModel[[ Length[RGEModel], RGEIndexCutoff ]],
	Print["The initial conditions are given above the cutoff of the given model"];
       Return[];
   ];
   If[pDown<0 || pUp<0, Throw[{pDown,pUp},RGELessThanZero]];

   If[pDown>pUp,{lDown,lUp}=Log[{pUp,pDown}],{lUp,lDown}=Log[{pUp,pDown}]];
   If[gRGEBoundaryScale<lDown,lDown=gRGEBoundaryScale];
   If[gRGEBoundaryScale>lUp,lUp=gRGEBoundaryScale];
   If[!(gRGESolutionValid && gRGEUp==lUp && gRGEDown==lDown),
   (* removing automatically generated entries *)
      If[RGERemoveAutoGeneratedEntries/.Options[lOpts],RGERmAutoGen[]];
      lRGEDown=GetRGEModelRange[lDown];
      lRGEUp=GetRGEModelRange[lUp];
      gRGEUp=lUp;
      gRGEDown=lDown;
(*Print["solving range containing ",Exp[gRGEBoundaryScale]];*)


(* solve range containing gRGEBoundaryScale *)
      lIndexRGEModel=GetRGEModelRange[gRGEBoundaryScale];
      lIndexModel=RGEModel[[ lIndexRGEModel, RGEIndexModel ]];

      lGoUp=lRGEUp>lIndexRGEModel;
      If[lGoUp,
          lUp=RGEModel[[ lIndexRGEModel, RGEIndexCutoff ]];
          lUpModel=gRGEModel[[ RGEModel[[lIndexRGEModel+1,RGEIndexModel]] ]];
          lUpOptions=RGEModel[[lIndexRGEModel+1,RGEIndexOptions]],
          lUpModel="";
          lUpOptions={};
      ];

      lGoDown=lRGEDown<lIndexRGEModel;
      If[lGoDown,
          lDown=RGEModel[[ lIndexRGEModel-1, RGEIndexCutoff]];
          lDownModel=gRGEModel[[ RGEModel[[lIndexRGEModel-1,RGEIndexModel]] ]];
          lDownOptions=RGEModel[[lIndexRGEModel-1,RGEIndexOptions]],
          lDownModel="";
          lDownOptions={};
      ];

{lSolution,lDown,lAddedModels}=gRGEModelSolve[[lIndexModel]][{lUp,lUpModel,lUpOptions},{lDown,lDownModel,lDownOptions},-1,gRGEBoundaryScale,gRGEInitial,
      Options[lNDSolveOpts],RGEModel[[lIndexRGEModel,RGEIndexOptions]] ];
      lIndexRGEModel+=lAddedModels;
      lGoDown=lRGEDown<lIndexRGEModel;
      RGEModel[[lIndexRGEModel, RGEIndexSolution]] =lSolution;

(* solving for ranges > gRGEBoundaryScale *)
     While[lGoUp,
(*Print["solving next range > ",Exp[gRGEBoundaryScale]];*)
	lOldIndexModel=RGEModel[[lIndexRGEModel,RGEIndexModel]];
      	lIndexRGEModel++;
	lIndexModel=RGEModel[[ lIndexRGEModel, RGEIndexModel ]];
	lDown=lUp;
	lGoUp=lRGEUp>lIndexRGEModel;

        If[lGoUp,
          lUp=RGEModel[[ lIndexRGEModel, RGEIndexCutoff ]];
          lUpModel=gRGEModel[[ RGEModel[[lIndexRGEModel+1,RGEIndexModel]] ]];
          lUpOptions=RGEModel[[lIndexRGEModel+1,RGEIndexOptions]],
          lUp=gRGEUp;
          lUpModel="";
          lUpOptions={};
        ];
        lDownModel=gRGEModel[[ RGEModel[[lIndexRGEModel-1,RGEIndexModel]] ]];
        lDownOptions=RGEModel[[lIndexRGEModel-1,RGEIndexOptions]];

(* lInitial is a list containing the initial values for the differential equation in this range *)	
	lInitial = gRGETransModel[[ lIndexModel, lOldIndexModel ]] [ lDown, -1, RGEModel[[ lIndexRGEModel-1, RGEIndexSolution]], RGEModel[[ lIndexRGEModel, RGEIndexOptions ]], RGEModel[[ lIndexRGEModel-1, RGEIndexOptions]] ]; (* initial values as list *)

      Options[lOpts]=RGEModel[[lIndexRGEModel,RGEIndexOptions]];
      SetOptions[lOpts,RGEFilterOptions[lOpts,RGESearchTransition->False]];
      Options[lOpts]=Options[lOpts]~Union~{RGESearchTransition->False};
	
        {lSolution,
      lNewScale,lAddedModels}=gRGEModelSolve[[lIndexModel]][{lUp,lUpModel,lUpOptions},{lDown,lDownModel,lDownOptions},+1,lDown,lInitial,
      Options[lNDSolveOpts], Options[lOpts]];
      RGEModel[[lIndexRGEModel, RGEIndexSolution]] =lSolution;
      
         ];

(* solving for ranges < gRGEBoundaryScale *)
      While[lGoDown,
(*Print["solving next range < ",Exp[gRGEBoundaryScale]];*)

	lOldIndexModel=RGEModel[[lIndexRGEModel,RGEIndexModel]];
        lIndexRGEModel--;
	lIndexModel=RGEModel[[ lIndexRGEModel, RGEIndexModel ]];
	lUp=lDown;
	lGoDown=lRGEDown<lIndexRGEModel;
        If[lGoDown,
          lDown=RGEModel[[ lIndexRGEModel-1, RGEIndexCutoff ]];
          lDownModel=gRGEModel[[ RGEModel[[lIndexRGEModel-1,RGEIndexModel]] ]];
          lDownOptions=RGEModel[[lIndexRGEModel-1,RGEIndexOptions]],
          lDown=gRGEDown;
          lDownModel="";
          lDownOptions={};
        ];
        lUpModel=gRGEModel[[ RGEModel[[lIndexRGEModel+1,RGEIndexModel]] ]];
        lUpOptions=RGEModel[[lIndexRGEModel+1,RGEIndexOptions]];
(* lInitial is a list containing the initial values for the differential
	equation in this range *)
	lInitial = gRGETransModel[[ lIndexModel, lOldIndexModel ]] [ lUp, +1,
	RGEModel[[ lIndexRGEModel+1, RGEIndexSolution]], RGEModel[[
	lIndexRGEModel, RGEIndexOptions ]], RGEModel[[ lIndexRGEModel+1,
	RGEIndexOptions]] ]; (* initial values as list *)
        {lSolution,lNewScale,lAddedModels}=gRGEModelSolve[[lIndexModel]][{lUp,lUpModel,lUpOptions},{lDown,lDownModel,lDownOptions},-1,lUp,lInitial,Options[lNDSolveOpts], RGEModel[[lIndexRGEModel,RGEIndexOptions]]];
      lIndexRGEModel+=lAddedModels;
      lDown=lNewScale;
      lGoDown=lRGEDown<lIndexRGEModel;
      RGEModel[[lIndexRGEModel, RGEIndexSolution]] =lSolution;
      ];
     gRGESolutionValid=True;
   ];
];


RGEReset[]:=Block[{},
(* resets all values which are needed by the calculation *)
	RGEModel={};
	gRGEInitial={}; 
	gRGEBoundaryScale={};
	gRGEDown=0;
	gRGEUp=0;
	gRGESolutionValid=False; 
];


RGERegisterModel[pName_,pContext_,pGetParameters_,pSolve_,pGetSolution_,pTransModel_,pSuggestInitial_,pSetOptions_,pGetOptions_]:=Block[{lIndexModel},
(* register a new model *)
(* exceptions: there already is a model named pName --> RGEModelAlreadyRegistered
*)
	If[MemberQ[gRGEModel,pName],Throw[pName,RGEModelAlreadyRegistered]];
        gRGEModel=Append[gRGEModel,pName];
        gRGEModelContext=Append[gRGEModelContext,pContext];
        gRGEModelSetOptions=Append[gRGEModelSetOptions,pSetOptions];
        gRGEModelGetOptions=Append[gRGEModelGetOptions,pGetOptions];
        gRGEModelGetParameters=Append[gRGEModelGetParameters,pGetParameters];
        gRGEModelSolve=Append[gRGEModelSolve,pSolve];
	gRGEModelGetSolution=Append[gRGEModelGetSolution,pGetSolution];
        gRGEModelGetInitial=Append[gRGEModelGetInitial,pSuggestInitial];
	gRGETransFunc=Append[gRGETransFunc,pTransModel];
        UpdateTransition[];
];


RGERmAutoGen[]:=Block[{lIndexRGEModel,lAutoGen},
(* removes all entries in RGEModel which have been generated automatically *)
	lOpts;
        lIndexRGEModel=1;
	While[lIndexRGEModel<=Length[RGEModel],
	    lAutoGen=(RGEAutoGenerated/.RGEModel[[lIndexRGEModel,RGEIndexOptions
	    ]])/.{RGEAutoGenerated->False};
	    If[MemberQ[gRGEModel,lAutoGen],
		RGEModel[[lIndexRGEModel,RGEIndexModel]]=Flatten[Position[gRGEModel,lAutoGen]][[1]];
		Options[lOpts]=RGEModel[[lIndexRGEModel,RGEIndexOptions]];
		SetOptions[lOpts,RGEAutoGenerated->False];
		RGEModel[[lIndexRGEModel,RGEIndexOptions]]=Options[lOpts];
		];
	    If[lAutoGen==True,
		RGEModel=Delete[RGEModel,lIndexRGEModel];
		lIndexRGEModel--;
		];
	    lIndexRGEModel++;
	];
];


RGESetEFTOptions[pModel_,pOpts___]:=Block[{lIndexModel,lIndexRGEModel},
(* sets the options of a model in RGEModel *)
   lOpts;
   lFilterOpts;
   If[Length[RGEModel]==0,
       Print["There is no model defined yet. Use RGEAddEFT to define the model
       you want to use before you use RGESetEFTOptions to change its options."];
       Return[];
   ];
   Do[  If[StringMatchQ[gRGEModel[[ RGEModel[[lIndexRGEModel,RGEIndexModel]] ]],pModel],
          Options[lFilterOpts]=gRGEModelGetOptions[[RGEModel[[lIndexRGEModel,RGEIndexModel]]]][];
	  Options[lOpts]={RGEFilterOptions[lFilterOpts,RGEModel[[lIndexRGEModel,RGEIndexOptions]]]};
	  SetOptions[lOpts,RGEFilterOptions[lOpts,pOpts]];
	  RGEModel[[lIndexRGEModel,RGEIndexOptions]]=Options[lOpts]~Union~{RGEFilterOptions[lFilterOpts,pOpts]};
      ],{lIndexRGEModel,1,Length[RGEModel]}];
   gRGESolutionValid=false;
];


RGESetModelOptions[pModel_,pOpts___]:=Block[{lIndexModel},
(* sets the options of a model *)
	Do[If[StringMatchQ[gRGEModel[[lIndexModel]],pModel],gRGEModelSetOptions[[ lIndexModel ]][Sequence[{pOpts}]]],{lIndexModel,1,Length[gRGEModel]}];
   gRGESolutionValid=false;
];


RGESetOptions[pModel_,pOpts___]:=RGESetEFTOptions[pModel,pOpts];


RGEChangeOptions[pScale_,pOpts___]:=Block[{lIndexRGEModel,lOpts,lFilterOpts},
(* sets the options of model at the scale pScale *)
   lIndexRGEModel=GetRGEModelRange[Log[pScale]];
   lOpts;
   lFilterOpts;
   Options[lFilterOpts]=gRGEModelGetOptions[[RGEModel[[lIndexRGEModel,RGEIndexModel]]]][];
   Options[lOpts]={RGEFilterOptions[lFilterOpts,RGEModel[[lIndexRGEModel,RGEIndexOptions]]]};
   SetOptions[lOpts,RGEFilterOptions[lOpts,pOpts]];
   RGEModel[[lIndexRGEModel,RGEIndexOptions]]=Options[lOpts]~Union~{RGEFilterOptions[lFilterOpts,pOpts]};
];


RGEGetEFTOptions[pModel_]:=Block[{lIndexRGEModel,lResult,lAuto},
(* returns the options of all models named pModel *)
   lOpts;
   If[Length[RGEModel]==0,
       Print["There is no model defined yet. Use RGEAddEFT to define the model
       you want to use before you use RGEGetEFTOptions to get its options."];
       Return[];
   ];
   lResult={};
   Do[
	lAuto=(RGEAutoGenerated/.RGEModel[[lIndexRGEModel,RGEIndexOptions]])/.{RGEAutoGenerated->False};
	Switch[ lAuto,
		True,True,
		_, If[StringMatchQ[gRGEModel[[RGEModel[[lIndexRGEModel,RGEIndexModel]]]],pModel],lResult=Append[lResult,{gRGEModel[[RGEModel[[lIndexRGEModel, RGEIndexModel]]]],RGEModel[[ lIndexRGEModel, RGEIndexOptions ]]}]]
		  ],{lIndexRGEModel,1,Length[RGEModel]}];
   Return[lResult];
];


RGEGetModelOptions[pModel_]:=Block[{lIndexModel,lResult},
(* returns the options of a model *)
   lResult={};
   Do[If[StringMatchQ[gRGEModel[[lIndexModel]],pModel],lResult=Append[lResult,{gRGEModel[[lIndexModel]],gRGEModelGetOptions[[lIndexModel]][]}]],{lIndexModel,1,Length[gRGEModel]}];
   Return[lResult];
];


RGEGetOptions[pModel_]:=RGEGetEFTOptions[pModel];


RGEGetSolution[pScale_?NumericQ,pName_:RGEAll,pDirection_:0]:=Block[{lIndexModel, lIndexRGEModel,lLogScale,lDirection},
(* returns the solution *)
(* exceptions:  Log[pScale] > gRGEUp || Log[pScale] < gRGEDown --> RGEOutOfRange
                lIndexRGEModel > Length[RGEModel] --> RGEScaleTooBig 
*)
        If[pDirection<=0,lDirection=0,lDirection=1];
        If[!gRGESolutionValid, RGESolve[gRGEDown,gRGEUp];];
        lLogScale=Log[pScale];
        If[lLogScale>gRGEUp||lLogScale<gRGEDown,Throw[lLogScale,RGEOutOfRange]]; 
	lIndexRGEModel=GetRGEModelRange[lLogScale];
        If[lIndexRGEModel<Length[RGEModel] && Chop[Abs[RGEModel[[
	lIndexRGEModel,RGEIndexCutoff ]] - lLogScale]]==0,lIndexRGEModel+=lDirection];
	If[lIndexRGEModel>Length[RGEModel],Throw[lIndexRGEModel,RGEScaleTooBig]];
        lIndexModel=RGEModel[[ lIndexRGEModel,RGEIndexModel ]];
	Return[(pName/.gRGEModelGetSolution[[ lIndexModel ]])[lLogScale,RGEModel[[ lIndexRGEModel,RGEIndexSolution ]], RGEModel[[ lIndexRGEModel, RGEIndexOptions]] ]];
];


RGEGetTransitions[]:=Block[{li,lModel,lTmpModel},
(* returns RGEModel essentially *)
    lModel={};
    Do[
        lTmpModel={ Exp[RGEModel[[li,RGEIndexCutoff]]],gRGEModel[[RGEModel[[li,RGEIndexModel]] ]], RGEModel[[li,RGEIndexOptions]]};
(*        Print[lTmpModel[[1]],": ",lTmpModel[[2]],", ",lTmpModel[[3]]];*)
        lModel=Append[lModel,lTmpModel],{li,Length[RGEModel], 1, -1}];
    Return[lModel];
];


RGEGetCutoff[pScale_,pDirection_:0]:=Block[{lIndexRGEModel},
(* returns RGEModel essentially *)
    lIndexRGEModel=GetRGEModelRange[Log[pScale],pDirection];
    Return[ Exp[RGEModel[[ lIndexRGEModel, RGEIndexCutoff ]]] ];
];


RGEGetModel[pScale_]:=Block[{lIndexRGEModel},
(* returns the name of the model at pScale and its options *)
   lIndexRGEModel=GetRGEModelRange[Log[pScale]];
   Return[{gRGEModel[[ RGEModel[[lIndexRGEModel,RGEIndexModel]] ]],RGEModel[[lIndexRGEModel,RGEIndexOptions]]}];
];


RGEGetSolveModel[pModel_]:=Block[{lIndexModel},
(* returns the function to solve the model *)
   lIndexModel=Flatten[ Position[gRGEModel,pModel] ][[ 1 ]];
   Return[gRGEModelSolve[[lIndexModel]]];
];


RGEDelModel[pScale_]:=Block[{lIndexRGEModel},
(* removes the model at pScale *)
   lIndexRGEModel=GetRGEModelRange[Log[pScale]];
   RGEModel=Delete[RGEModel,lIndexRGEModel];
];


RGELoadAll[pFile_]:=Block[{li,lModel,lModelContext},
   Needs["REAP`RGESymbol`"];
   Needs["REAP`RGEUtilities`"];
   Needs["REAP`RGEParameters`"];
   Needs["REAP`RGEInitial`"];
   Needs["MixingParameterTools`MPT3x3`"];
   Print["loading variables..."];
   Get[pFile];
   lModel=gRGEModel;
   lModelContext=gRGEModelContext;
   gRGEModel={};
   gRGEModelContext={};
   Do[
      Print["loading ",lModel[[li]]];
      Needs[lModelContext[[ li ]] ];
      RGESetModelOptions[ lModel[[ li ]], gRGEModelOptions[[ li ]] ],{li,1,Length[lModel]}];
   Get[pFile];
];


RGESaveAll[pFile_]:=Block[{li,lModel,lModelContext},
   gRGEModelOptions={};
   Do[Print["getting options of ",gRGEModel[[li]]];
      gRGEModelOptions=Append[ gRGEModelOptions, RGEGetModelOptions[gRGEModel[[ li ]] ][[1,2]] ],{li,1,Length[gRGEModel]}];
   DeleteFile[pFile];
   Print["saving variables ..."];
   Save[pFile,{
        gRGEModel,gRGEModelContext,gRGEModelOptions,
        RGEModel,gRGEBoundaryScale,gRGEInitial,gRGEDown,gRGEUp,gRGESolutionValid,
	gRGEModelGetParameters,gRGEModelSolve,gRGEModelSetOptions,gRGEModelGetOptions,gRGEModelGetInitial,gRGETransFunc,gRGEModelGetSolution,gRGETransModel
   }];
];


RGELoadResults[pModel_]:=Block[{},
	RGEModel=pModel;
	];


RGESaveResults[]:=Block[{},
	Return[RGEModel];
	];


RGESaveInitialData[]:=Block[{},
	Return[{RGEBoundaryScale->gRGEBoundaryScale}
	~Join~gRGEInitial~Join~{RGEUpperBound->gRGEUp,RGELowerBound->gRGEDown, RGEModelData->RGEModel}];
	];


 End[];

 Protect[RGESetInitial,RGEGetRange,RGEGetInitial,RGEGetParameters,RGEAddEFT,RGEAdd,RGESolve,RGEReset,RGERegisterModel,RGERmAutoGen,RGESetEFTOptions,RGESetModelOptions,RGESetOptions,RGEChangeOptions,RGEGetEFTOptions,RGEGetModelOptions,RGEGetOptions,RGEGetSolution,RGEGetTransitions,RGEGetCutoff,RGEGetModel,RGEGetSolveModel,RGEDelModel,RGELoadAll,RGESaveAll,RGELoadResults,RGESaveResults,RGESaveInitialData];

 EndPackage[];

